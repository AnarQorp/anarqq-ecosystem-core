import axios from 'axios';
import { getActiveIdentity } from '../state/identity';
import { PrivacyMiddleware } from '../services/qsocial/PrivacyMiddleware';
import { PrivacyService } from '../services/qsocial/PrivacyService';
import { EncryptionService } from '../services/qsocial/EncryptionService';
import { SecureStorageService } from '../services/qsocial/SecureStorageService';
import { PrivacyAnalyticsService } from '../services/qsocial/PrivacyAnalyticsService';
import type { 
  QsocialPost, 
  QsocialComment, 
  Subcommunity, 
  UserReputation,
  CreatePostRequest,
  UpdatePostRequest,
  CreateCommentRequest,
  UpdateCommentRequest,
  CreateSubcommunityRequest,
  UpdateSubcommunityRequest,
  FeedOptions,
  CommentOptions,
  VoteResult,
  CrossPostOptions,
  User
} from '../types/qsocial';
import type { SearchFilters, SearchResults, SearchResultItem } from '../services/qsocial/SearchService';
import type { RecommendationResult, TrendingItem, FeaturedContent } from '../services/qsocial/RecommendationService';

const API_BASE_URL = '/api/qsocial';

/**
 * Helper function to sign a message with the active identity
 */
async function signMessage(message: string): Promise<string> {
  const identity = getActiveIdentity();
  if (!identity) {
    throw new Error('No active identity found');
  }
  
  if (identity.signMessage) {
    return await identity.signMessage(message);
  }
  
  // Create mock signature compatible with backend middleware
  // This simulates the signature that would be generated by sQuid identity
  const data = `${message}:${identity.did}`;
  
  // Use Web Crypto API for proper hashing (compatible with backend)
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(data);
  
  try {
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const signature = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return signature;
  } catch (error) {
    // Fallback for environments without crypto.subtle
    console.warn('Web Crypto API not available, using fallback signature');
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16).padStart(8, '0').repeat(8);
  }
}

/**
 * Post Service API
 */
export class PostService {
  /**
   * Create a new post
   */
  static async createPost(post: CreatePostRequest): Promise<QsocialPost> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    // Validate privacy settings before creating post
    const privacyValidation = await PrivacyMiddleware.validatePostCreation(post, identity.did);
    if (!privacyValidation.success) {
      throw new Error(privacyValidation.error || 'Privacy validation failed');
    }

    const validatedPost = privacyValidation.data!;

    const message = {
      action: 'createPost',
      data: validatedPost,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    // Apply encryption if needed
    const encryptedPost = await EncryptionService.encryptPost({
      ...validatedPost,
      authorId: identity.did
    });

    const response = await axios.post(
      `${API_BASE_URL}/posts`,
      encryptedPost,
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );

    const createdPost = response.data;
    
    // Track analytics
    await PrivacyAnalyticsService.trackPostCreated(createdPost);

    return createdPost;
  }

  /**
   * Get a post by ID
   */
  static async getPost(id: string): Promise<QsocialPost> {
    const response = await axios.get(`${API_BASE_URL}/posts/${id}`);
    return response.data;
  }

  /**
   * Update a post
   */
  static async updatePost(id: string, updates: UpdatePostRequest): Promise<QsocialPost> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'updatePost',
      postId: id,
      data: updates,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    const response = await axios.put(
      `${API_BASE_URL}/posts/${id}`,
      updates,
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );

    return response.data;
  }

  /**
   * Delete a post
   */
  static async deletePost(id: string): Promise<void> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'deletePost',
      postId: id,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    await axios.delete(`${API_BASE_URL}/posts/${id}`, {
      headers: {
        'X-Identity-DID': identity.did,
        'X-Signature': signature,
        'X-Message': JSON.stringify(message)
      }
    });
  }

  /**
   * Get main feed
   */
  static async getFeed(options: FeedOptions = {}): Promise<QsocialPost[]> {
    const params = new URLSearchParams();
    if (options.limit) params.append('limit', options.limit.toString());
    if (options.offset) params.append('offset', options.offset.toString());
    if (options.sortBy) params.append('sortBy', options.sortBy);
    if (options.timeRange) params.append('timeRange', options.timeRange);

    const response = await axios.get(`${API_BASE_URL}/feed?${params.toString()}`);
    const posts = response.data.posts || [];

    // Apply privacy filtering
    const identity = getActiveIdentity();
    const filterResult = await PrivacyMiddleware.filterPosts(posts, identity?.did);
    
    if (!filterResult.success) {
      console.warn('Privacy filtering failed:', filterResult.error);
      return posts; // Return unfiltered posts as fallback
    }

    return filterResult.data || [];
  }

  /**
   * Get subcommunity feed
   */
  static async getSubcommunityFeed(subcommunityId: string, options: FeedOptions = {}): Promise<QsocialPost[]> {
    const params = new URLSearchParams();
    if (options.limit) params.append('limit', options.limit.toString());
    if (options.offset) params.append('offset', options.offset.toString());
    if (options.sortBy) params.append('sortBy', options.sortBy);
    if (options.timeRange) params.append('timeRange', options.timeRange);

    const response = await axios.get(`${API_BASE_URL}/subcommunities/${subcommunityId}/feed?${params.toString()}`);
    return response.data.posts || [];
  }

  /**
   * Get user posts
   */
  static async getUserPosts(userId: string, options: FeedOptions = {}): Promise<QsocialPost[]> {
    const params = new URLSearchParams();
    if (options.limit) params.append('limit', options.limit.toString());
    if (options.offset) params.append('offset', options.offset.toString());
    if (options.sortBy) params.append('sortBy', options.sortBy);

    const response = await axios.get(`${API_BASE_URL}/users/${userId}/posts?${params.toString()}`);
    return response.data.posts || [];
  }

  /**
   * Create cross-post from another module
   */
  static async createCrossPost(sourceModule: string, sourceId: string, options: CrossPostOptions): Promise<QsocialPost> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'createCrossPost',
      sourceModule,
      sourceId,
      options,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    const response = await axios.post(
      `${API_BASE_URL}/cross-posts`,
      {
        sourceModule,
        sourceId,
        ...options,
        authorId: identity.did
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );

    return response.data;
  }

  /**
   * Vote on a post
   */
  static async votePost(postId: string, vote: 'up' | 'down' | 'remove'): Promise<VoteResult> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'votePost',
      postId,
      vote,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    const response = await axios.post(
      `${API_BASE_URL}/posts/${postId}/vote`,
      { vote },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );

    return response.data;
  }
}

/**
 * Comment Service API
 */
export class CommentService {
  /**
   * Create a new comment
   */
  static async createComment(comment: CreateCommentRequest): Promise<QsocialComment> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    // Get parent post for privacy validation
    let parentPost: QsocialPost | undefined;
    try {
      parentPost = await PostService.getPost(comment.postId);
    } catch (error) {
      console.warn('Could not fetch parent post for privacy validation');
    }

    // Validate privacy settings before creating comment
    const privacyValidation = await PrivacyMiddleware.validateCommentCreation(
      comment, 
      identity.did, 
      parentPost
    );
    if (!privacyValidation.success) {
      throw new Error(privacyValidation.error || 'Privacy validation failed');
    }

    const validatedComment = privacyValidation.data!;

    const message = {
      action: 'createComment',
      data: validatedComment,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    const response = await axios.post(
      `${API_BASE_URL}/comments`,
      {
        ...validatedComment,
        authorId: identity.did
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );

    return response.data;
  }

  /**
   * Get a comment by ID
   */
  static async getComment(id: string): Promise<QsocialComment> {
    const response = await axios.get(`${API_BASE_URL}/comments/${id}`);
    return response.data;
  }

  /**
   * Update a comment
   */
  static async updateComment(id: string, updates: UpdateCommentRequest): Promise<QsocialComment> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'updateComment',
      commentId: id,
      data: updates,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    const response = await axios.put(
      `${API_BASE_URL}/comments/${id}`,
      updates,
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );

    return response.data;
  }

  /**
   * Delete a comment
   */
  static async deleteComment(id: string): Promise<void> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'deleteComment',
      commentId: id,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    await axios.delete(`${API_BASE_URL}/comments/${id}`, {
      headers: {
        'X-Identity-DID': identity.did,
        'X-Signature': signature,
        'X-Message': JSON.stringify(message)
      }
    });
  }

  /**
   * Get comments for a post
   */
  static async getPostComments(postId: string, options: CommentOptions = {}): Promise<QsocialComment[]> {
    const params = new URLSearchParams();
    if (options.limit) params.append('limit', options.limit.toString());
    if (options.offset) params.append('offset', options.offset.toString());
    if (options.sortBy) params.append('sortBy', options.sortBy);
    if (options.maxDepth !== undefined) params.append('maxDepth', options.maxDepth.toString());

    const response = await axios.get(`${API_BASE_URL}/posts/${postId}/comments?${params.toString()}`);
    return response.data.comments || [];
  }

  /**
   * Get comment thread
   */
  static async getCommentThread(commentId: string): Promise<QsocialComment[]> {
    const response = await axios.get(`${API_BASE_URL}/comments/${commentId}/thread`);
    return response.data.comments || [];
  }

  /**
   * Vote on a comment
   */
  static async voteComment(commentId: string, vote: 'up' | 'down' | 'remove'): Promise<VoteResult> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'voteComment',
      commentId,
      vote,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    const response = await axios.post(
      `${API_BASE_URL}/comments/${commentId}/vote`,
      { vote },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );

    return response.data;
  }
}

/**
 * Subcommunity Service API
 */
export class SubcommunityService {
  /**
   * Create a new subcommunity
   */
  static async createSubcommunity(subcommunity: CreateSubcommunityRequest): Promise<Subcommunity> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'createSubcommunity',
      data: subcommunity,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    const response = await axios.post(
      `${API_BASE_URL}/subcommunities`,
      {
        ...subcommunity,
        creatorId: identity.did
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );

    return response.data;
  }

  /**
   * Get a subcommunity by ID
   */
  static async getSubcommunity(id: string): Promise<Subcommunity> {
    const response = await axios.get(`${API_BASE_URL}/subcommunities/${id}`);
    return response.data;
  }

  /**
   * Update a subcommunity
   */
  static async updateSubcommunity(id: string, updates: UpdateSubcommunityRequest): Promise<Subcommunity> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'updateSubcommunity',
      subcommunityId: id,
      data: updates,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    const response = await axios.put(
      `${API_BASE_URL}/subcommunities/${id}`,
      updates,
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );

    return response.data;
  }

  /**
   * Delete a subcommunity
   */
  static async deleteSubcommunity(id: string): Promise<void> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'deleteSubcommunity',
      subcommunityId: id,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    await axios.delete(`${API_BASE_URL}/subcommunities/${id}`, {
      headers: {
        'X-Identity-DID': identity.did,
        'X-Signature': signature,
        'X-Message': JSON.stringify(message)
      }
    });
  }

  /**
   * Join a subcommunity
   */
  static async joinSubcommunity(subcommunityId: string): Promise<void> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'joinSubcommunity',
      subcommunityId,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    await axios.post(
      `${API_BASE_URL}/subcommunities/${subcommunityId}/join`,
      {},
      {
        headers: {
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );
  }

  /**
   * Leave a subcommunity
   */
  static async leaveSubcommunity(subcommunityId: string): Promise<void> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'leaveSubcommunity',
      subcommunityId,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    await axios.post(
      `${API_BASE_URL}/subcommunities/${subcommunityId}/leave`,
      {},
      {
        headers: {
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );
  }

  /**
   * Search subcommunities
   */
  static async searchSubcommunities(query: string): Promise<Subcommunity[]> {
    const params = new URLSearchParams();
    params.append('q', query);

    const response = await axios.get(`${API_BASE_URL}/subcommunities/search?${params.toString()}`);
    return response.data.subcommunities || [];
  }

  /**
   * Get trending subcommunities
   */
  static async getTrendingSubcommunities(): Promise<Subcommunity[]> {
    const response = await axios.get(`${API_BASE_URL}/subcommunities/trending`);
    return response.data.subcommunities || [];
  }

  /**
   * Get subcommunity members
   */
  static async getMembers(subcommunityId: string): Promise<User[]> {
    const response = await axios.get(`${API_BASE_URL}/subcommunities/${subcommunityId}/members`);
    return response.data.members || [];
  }

  /**
   * Add moderator to subcommunity
   */
  static async addModerator(subcommunityId: string, userId: string): Promise<void> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'addModerator',
      subcommunityId,
      userId,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    await axios.post(
      `${API_BASE_URL}/subcommunities/${subcommunityId}/moderators`,
      { userId },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );
  }

  /**
   * Remove moderator from subcommunity
   */
  static async removeModerator(subcommunityId: string, userId: string): Promise<void> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'removeModerator',
      subcommunityId,
      userId,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    await axios.delete(`${API_BASE_URL}/subcommunities/${subcommunityId}/moderators/${userId}`, {
      headers: {
        'X-Identity-DID': identity.did,
        'X-Signature': signature,
        'X-Message': JSON.stringify(message)
      }
    });
  }
}

/**
 * Reputation Service API
 */
export class ReputationService {
  /**
   * Get user reputation
   */
  static async getUserReputation(userId: string): Promise<UserReputation> {
    const response = await axios.get(`${API_BASE_URL}/users/${userId}/reputation`);
    return response.data;
  }

  /**
   * Get current user's reputation
   */
  static async getMyReputation(): Promise<UserReputation> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    return this.getUserReputation(identity.did);
  }
}

/**
 * Search Service API
 */
export class SearchService {
  /**
   * Perform full-text search across all content
   */
  static async search(query: string, filters: SearchFilters = {}): Promise<SearchResults> {
    const params = new URLSearchParams();
    params.append('q', query);
    
    if (filters.contentType) params.append('contentType', filters.contentType);
    if (filters.dateRange?.from) params.append('dateFrom', filters.dateRange.from.toISOString());
    if (filters.dateRange?.to) params.append('dateTo', filters.dateRange.to.toISOString());
    if (filters.subcommunityId) params.append('subcommunityId', filters.subcommunityId);
    if (filters.authorId) params.append('authorId', filters.authorId);
    if (filters.tags) params.append('tags', filters.tags.join(','));
    if (filters.minQarma) params.append('minQarma', filters.minQarma.toString());
    if (filters.sortBy) params.append('sortBy', filters.sortBy);
    if (filters.limit) params.append('limit', filters.limit.toString());
    if (filters.offset) params.append('offset', filters.offset.toString());

    const response = await axios.get(`${API_BASE_URL}/search?${params.toString()}`);
    return response.data;
  }

  /**
   * Search specifically for posts
   */
  static async searchPosts(query: string, filters: Omit<SearchFilters, 'contentType'> = {}): Promise<QsocialPost[]> {
    const results = await this.search(query, { ...filters, contentType: 'posts' });
    return results.results.map(r => r.data as QsocialPost);
  }

  /**
   * Search specifically for comments
   */
  static async searchComments(query: string, filters: Omit<SearchFilters, 'contentType'> = {}): Promise<QsocialComment[]> {
    const results = await this.search(query, { ...filters, contentType: 'comments' });
    return results.results.map(r => r.data as QsocialComment);
  }

  /**
   * Get trending content
   */
  static async getTrendingContent(timeRange: 'hour' | 'day' | 'week' | 'month' = 'day', limit: number = 20): Promise<SearchResultItem[]> {
    const params = new URLSearchParams();
    params.append('timeRange', timeRange);
    params.append('limit', limit.toString());

    const response = await axios.get(`${API_BASE_URL}/trending?${params.toString()}`);
    return response.data.results || [];
  }

  /**
   * Get content recommendations for current user
   */
  static async getRecommendations(limit: number = 20): Promise<SearchResultItem[]> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const params = new URLSearchParams();
    params.append('limit', limit.toString());

    const response = await axios.get(`${API_BASE_URL}/recommendations?${params.toString()}`, {
      headers: {
        'X-Identity-DID': identity.did
      }
    });
    return response.data.results || [];
  }

  /**
   * Get content recommendations for a specific user
   */
  static async getUserRecommendations(userId: string, limit: number = 20): Promise<SearchResultItem[]> {
    const params = new URLSearchParams();
    params.append('limit', limit.toString());

    const response = await axios.get(`${API_BASE_URL}/users/${userId}/recommendations?${params.toString()}`);
    return response.data.results || [];
  }
}

/**
 * Recommendation Service API
 */
export class RecommendationService {
  /**
   * Get personalized recommendations for current user
   */
  static async getPersonalizedRecommendations(limit: number = 20, excludeViewed: string[] = []): Promise<RecommendationResult[]> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const params = new URLSearchParams();
    params.append('limit', limit.toString());
    if (excludeViewed.length > 0) {
      params.append('excludeViewed', excludeViewed.join(','));
    }

    const response = await axios.get(`${API_BASE_URL}/recommendations/personalized?${params.toString()}`, {
      headers: {
        'X-Identity-DID': identity.did
      }
    });
    return response.data.results || [];
  }

  /**
   * Get trending content with advanced metrics
   */
  static async getTrendingContent(
    timeframe: 'hour' | 'day' | 'week' | 'month' = 'day',
    limit: number = 20,
    contentType?: 'posts' | 'comments' | 'subcommunities'
  ): Promise<TrendingItem[]> {
    const params = new URLSearchParams();
    params.append('timeframe', timeframe);
    params.append('limit', limit.toString());
    if (contentType) params.append('contentType', contentType);

    const response = await axios.get(`${API_BASE_URL}/recommendations/trending?${params.toString()}`);
    return response.data.results || [];
  }

  /**
   * Get featured content
   */
  static async getFeaturedContent(
    limit: number = 10,
    category?: 'editorial' | 'community_choice' | 'algorithm' | 'milestone'
  ): Promise<FeaturedContent[]> {
    const params = new URLSearchParams();
    params.append('limit', limit.toString());
    if (category) params.append('category', category);

    const response = await axios.get(`${API_BASE_URL}/recommendations/featured?${params.toString()}`);
    return response.data.results || [];
  }

  /**
   * Get discovery recommendations for exploring new content
   */
  static async getDiscoveryRecommendations(limit: number = 15): Promise<RecommendationResult[]> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const params = new URLSearchParams();
    params.append('limit', limit.toString());

    const response = await axios.get(`${API_BASE_URL}/recommendations/discovery?${params.toString()}`, {
      headers: {
        'X-Identity-DID': identity.did
      }
    });
    return response.data.results || [];
  }

  /**
   * Get social recommendations based on user's network
   */
  static async getSocialRecommendations(limit: number = 15): Promise<RecommendationResult[]> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const params = new URLSearchParams();
    params.append('limit', limit.toString());

    const response = await axios.get(`${API_BASE_URL}/recommendations/social?${params.toString()}`, {
      headers: {
        'X-Identity-DID': identity.did
      }
    });
    return response.data.results || [];
  }

  /**
   * Feature content (for moderators/admins)
   */
  static async featureContent(
    contentId: string,
    contentType: 'post' | 'subcommunity',
    reason: 'editorial' | 'community_choice' | 'algorithm' | 'milestone',
    priority: number = 1,
    expiresAt?: Date
  ): Promise<void> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'featureContent',
      contentId,
      contentType,
      reason,
      priority,
      expiresAt: expiresAt?.toISOString(),
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    await axios.post(
      `${API_BASE_URL}/recommendations/feature`,
      {
        contentId,
        contentType,
        reason,
        priority,
        expiresAt: expiresAt?.toISOString()
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );
  }

  /**
   * Remove featured content
   */
  static async unfeatureContent(contentId: string): Promise<void> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'unfeatureContent',
      contentId,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    await axios.delete(`${API_BASE_URL}/recommendations/feature/${contentId}`, {
      headers: {
        'X-Identity-DID': identity.did,
        'X-Signature': signature,
        'X-Message': JSON.stringify(message)
      }
    });
  }

  /**
   * Update user interest profile based on activity
   */
  static async updateUserActivity(activity: {
    type: 'view' | 'vote' | 'comment' | 'share';
    contentId: string;
    contentType: 'post' | 'comment';
    tags?: string[];
    subcommunityId?: string;
    authorId?: string;
    duration?: number;
  }): Promise<void> {
    const identity = getActiveIdentity();
    if (!identity) {
      throw new Error('No active identity found');
    }

    const message = {
      action: 'updateUserActivity',
      activity,
      timestamp: new Date().toISOString(),
      did: identity.did
    };

    const signature = await signMessage(JSON.stringify(message));

    await axios.post(
      `${API_BASE_URL}/recommendations/activity`,
      { activity },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Identity-DID': identity.did,
          'X-Signature': signature,
          'X-Message': JSON.stringify(message)
        }
      }
    );
  }
}

/**
 * Health check for Qsocial service
 */
export async function checkHealth() {
  const response = await axios.get(`${API_BASE_URL}/health`);
  return response.data;
}